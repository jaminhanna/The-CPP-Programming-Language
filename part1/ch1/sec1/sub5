1.1.5 Examples and References

This book emphasizes program organization rather than the design of algorithms. Consequently, I avoid clever or harder-to-understand algorithms. A trivial algorithm is typically better suited to illstrate an aspect of the language definition or a point about program structure. For example, I use a Shell sort where, in real code, a quicksort would be better. Often, reimplementation with a more suitable algorithm is an exercise. In real code, a call of a library function is typically more appropriate than the code used here to illustrate language features.
Textbook examples necessarily give a warped view of software development. By clarifying and simplifying the examples, the complexities that arise from scale disappear. I see no substitute for writing realistically sized programs in order to get an impression of what programming and a programming language are really like. This book concentrates on the language features and the standard-library facilities. These are the basic techniques from which every program is composed. The rules and techniques for such composition are emphasized.
the selection of examples reflects my background in compilers, foundation libraries, and simulations. The emphasis reflects my interest in systems programming. Examples are simplified versions of what is found in real code. The simplification is necessary to keep programming language and design points from getting lost in details. My ideal is the shortest and clearest example that illulustrates a design principle, a programming technique, a language construct, or a library feature. There are no "cute" examples without counterparts in real code. For purely language-technical examples, I use variables named x and y, types called A and B, and functions called f() and g().
When possible the C++ language and library features are presented in the context of their use rather than in the dry manner of a manual. The language features presented and the detail in which they are described roughly reflect my view of what is needed for effective use of C++. The purpose is to give you an idea of how a feature can be used, often in combination with other features. An understanding of every language-technical detail of a language feature or library component is neither necessary nor sufficient for writing good programs. In fact, an obsession with understanding every little detail is a prescription for awful -- overelaborate and overly clever - code. What is needed is an understanding of design and programming techniques together with an appreciation of application domains.
I assume you have access to online information sources. The final arbiter of language and standard-library rules is the ISO C++ standard [C++,2011].
References to parts of this book are of the form §2.3.4 (Chapter 2, section 3, subsection 4) and §iso.5.3.1 (ISO C++ standard, §5.3.1). Italics are used sparingly for emphasis (e.g., "a string literal is not acceptable"), for first occurrences of important concepts (e.g., polymorphism), and for comments in code examples.
To save a few trees and to simplify additions, the hundreds of exercises for this book have been moved to the Web. Look for them at stroustrup.com.
The language and library used in this book are "pure C++" as defined by the C++ standard [C++,22011]. Therefore, the examples should run on every up-to-date C++ implementation. The major program fragments in this book were tried using several C++ implementations. Examples using features only recently adopted into C++ didn't compile on every implementation. However, I see no point in mentioning which implementations failed to compile which examples. Such information would soon be out of date because implementers are working hard to ensure that their implementations correctly accept every C++ feature. See Chapter 44 for suggestions on how to cope with older C++ compilers and with code written for C compilers.
I use C++11 features freely wherever I find them most appropriate. For example, I prefer {}-style initialization and using for type aliases. In places, that usage may startle "old timers." However, being startled is often a good way to start reviewing material. On the other hand, I don't use new features just because they are new; my ideal is the most elegant expression of the fundamental ideas -- and that may very well be using something that has been in C++ or even in C for ages.
Obviously, if you have to use a pre-C++11 compiler (say, because some of your customers have not yet upgraded to the current standard), you have to refrain from using novel features. However, please don't assume that "the old ways" are better or simpler just because they are old and familiar. §44.2 summarizes the differences between C++98 and C++11.
