2.2.2 Types, Variables, and Arithmetic

Every name and every expression has a type that determines the operations that may be performed on it. For example, the declaration

	int inch;

specifies that inch is of type int; that is, int is an integer variable.
	A declaration is a statement that introduces a name into the program. It specifies a type for the named entity:
	-	A type defines a set of possible values and a set of operations (for an object).
	-	An object is some memory that holds a value of some type.
	-	A value is a set of bits interpreted according to a type.
	-	A variable is a named object.
	C++ offers a variety of fundamental types. For example:

	bool	// Boolean, possible values are true and false
	char	// character, for example, 'a', 'z', and '9'
	int	// integer, for example, 1, 42, and 1066
	double	// double-precision floating-point number, for example, 3.14 and 299793.0

Each fundamental type corresponds directly to hardware facilities and has a fixed size that determines the range of values that can be stored in it:

	bool:	|	|
	char:	|	|
	int:	|	|	|	|	|
	double:	|	|	|	|	|	|	|	|	|

A char variable is of the natural size to hold a character on a given machine (typically an 8-bit byte), and the sizes of other are quoted in multiples of the size of a char. The size of a type is implementation-defined (i.e., it can vary among different machines) and can be obtained by the sizeof operator; for example, sizeof(char) equals 1 and sizeof(int) is often 4.
	The arithmetic operators can be used for appropriate combinations of these types:

	x+y	// plus
	+x	// unary plus
	x-y	// minus
	-x	// unary minux
	x*y	// multiply
	x/y	// divide
	x%y	// remainder (modulus) for integers

So can the comparison operators:

	x==y	// equal
	x!=y	// not equal
	x<y	// less than
	x>y	// greater than
	x<=y	// less than or equal
	x>=y	// greater than or equal

In assignments and in arithmetic operations, C++ performs all meaningful conversions (§10.5.3) between the basic types so that they can be mixed freely:

	void some_function()	// function that doesn't return a value
	{
		double d = 2.2;		// initialize floating-point number
		int i = 7;		// initialize integer
		d = d+i;		// assign sum to d
		i = d*i;		// assign product to i (truncating the double d*i to an int)
	}

Note that = is the assignment operator and == tests equality.
	C++ offers a variety of notations for expressing initialization, such as the = used above, and a universal form based on curly-brace-delimited initializer lists:

	double d1 = 2.3;
	double d2 {2.3};

	complex<double> z = 1;		// a complex number with double-precision floating-point scalars
	complex<double> z2 {d1,d2};
	complex<double> z3 = {1,2};	// the = is optional with { ... }

	vector<int> v {1,2,3,4,5,6};	// a vector of ints

The = form is traditional and dates back to C, but if in doubt, use the general {}-list form (§6.3.5.2). If nothing else, it saves you from conversions that lose information (narrowing conversions; §10.5):

	int i1 = 7.2;		// i1 becomes 7
	int i2 {7.2};		// error: floating-point to integer conversion
	int i3 = {7.2};		// error: floating-point to integer conversion (the = is redundant)

A constant (§2.2.3) cannot be left uninitialized and a variable should only be left uninitialized in extremely rare circumstances. Don't introduce a name until you have a suitable value for it. User-defined types (such as string, vector, Matrix, Motor_controller, and Orc_warrior) can be defined to be implicitly initialized (§3.2.1.1).
	When defining a variable, you don't actually need to state its type explicitly when it can be deduced from the initializer:

	auto b = true;		// a bool
	auto ch = 'x';		// a char
	auto i = 123;		// an int
	auto d = 1.2;		// a double
	auto z = sqrt(y)	// z has the type of whatever sqrt(y) returns

With auto, we use the = syntax because there is no type conversion involved that might cause problems (§6.3.6.2).
	We use auto where we don't have a specific reason to mention the type explicitly. "Specific reasons" include:
	-	The definition is in a large scope where we want to make the type clearly visible to readers of our code.
	-	We want to be explicit about a variable's range or precision (e.g., double rather than float).
Using auto, we avoid redundancy and writing long type names. This is especially important in generic programming where the exact type of an object can be hard for the programmer to know and the type names can be quite long (§4.5.1).
	In addition to the conventional arithmetic and logical operators (§10.3), C++ offers more specific operations for modifying a variable:

	x+=y	// x = x+y
	++x	// increment: x = x+1
	x-=y	// x = x*y
	--x	// decrement: x = x-1
	x+=y	// scaling: x = x*y
	x/=y	// scaling: x = x/y
	x%=y	// x = x%y

These operators are concise, convenient, and very frequently used.
