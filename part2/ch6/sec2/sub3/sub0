6.2.3 Character Types

There are many character sets and character set encodings in use: C++
provides a variety of character types to reflect that -- often
bewildering -- variety:
  - char: The default character type, used for program text. A char is
    used for the implementation's character set and is usually 8 bits.
  - signed char: Like char, but guaranteed to be signed, that is,
    capable of holding both positive and negative values.
  - unsigned char: Like char, but guaranteed to be unsigned.
  - wchar_t: Provided to hold characters of a larger character set such
    as Unicode (see §7.3.2.2). The size of wchar_t is
    implementation-defined and large enough to hold the largest
    character set supported by the implementation's locale (Chapter
    39).
  - char16_t: A type for holding 16-bit character sets, such as UTF-16.
  - char32_t: A type for holding 32-bit character sets, such as UTF-32.
These are six distinct types (despite the fact that the _t suffix is
often used to denote aliases; §6.5). On each implementation, the char
type will be identical to that of either signed char or unsigned char,
but these names are still considered separate types.
  A char variable can hold a character of the implementation's
character set. For example:

  char ch = 'a';

Almost universally, a char has 8 bits so that it can hold one of 256
different values. Typically, the character set is a variant of
ISO-646, for example ASCII, thus providing the characters appearing on
your keyboard. Many problems arise from the fact that this set of
characters is only partially standardized.
  Serious variations occur between character sets supporting different
natural languages and between character sets supporting the same
natural language in different ways. Here, we are interested only in how
such differences affect the rules of C++. The larger and more
interesting issue of how to program in a multilingual,
multi-character-set environment is beyond the scope of this book,
although it is alluded to in several places (§6.2.3, §36.2.1, Chapter
39).
  It is safe to assume that the implementation character set includes
the decimal digits, the 26 alphabetic characters of English, and some
of the basic punctuation characters. It is not safe to assume that:
  - There are no more than 127 characters in an 8-bit character set
    (e.g., some sets provide 255 characters).
  - There are no more alphabetic characters than English provides (most
    European languages provide more, e.g., æ, þ, and ß).
  - The alphabetic characters are contiguous (EBCDIC leaves a gap
    between 'i' and 'j').
  - Every character used to write C++ is available (e.g., some national
    character sets do not provide {, }, [, ], |, and \).
  - A char fits in 1 byte. There are embedded processors without byte
    accessing hardware for which a char is 4 bytes. Also, one could
    reasonably use a 16-bit Unicode encoding for the basic chars.
Whenever possible, we should avoid making assumptions about the
representation of objects. This general rule applies even to
characters.
  Each character has an integer value in the character set used by the
implementation. For example, the value of 'b' is 98 in the ASCII
character set. Here is a loop that outputs the integer value of any
character you care to input:

  void intval()
  {
      for (char c; cin >> c; )
          cout << "the value of '" << c << "' is " << int{c} << '\n';
  }

The notation int{c} gives the integer value for a character c ("the int
we can construct from c"). The possibility of converting a char to an
integer raises the question: is a char signed or unsigned? The 256
values represented by an 8-bit byte can be represented as the values 0
to 255 or as the values -127 to 127. No, not -128 to 127 as one might
expect: the C++ standard leaves open the possibility of
one's-complement hardware and that eliminates one value; thus, a use of
-128 is non-portable. Unfortunately, the choice of signed or unsigned
for a plain char is implementation-defined. C++ providees two types for
which the answer is definite: signed char, which can hold at least the
values -127 to 127, and unsigned char, which can hold at least the
values 0 to 255. Fortunately, the difference only matters for values
outside the 0 to 127 range, and the most common characters are within
that range.
  Values outside that range stored in a plain char can lead to subtle
portability problems. See §6.2.3.1 if you need to use more than one
type of char or if you store integers in char variables.
  Note that the character types are integral types (§6.2.1) so that
arithmetic and bitwise logical operations (§10.3) apply. For example:

  void digits()
  {
      for (int i=0; i!=10; ++i)
          cout << static_cast<char>('0'+i);
  }

This is a way of writing the ten digits to cout. The character literal
'0' is converted to its integer value and i is added. The resulting int
is then converted to a char and written to cout. Plain '0'+i is an int,
so if I had left out the static_cast<char>, the output would have been
something like 48, 49, and so on, rather than 0, 1, and so on.
